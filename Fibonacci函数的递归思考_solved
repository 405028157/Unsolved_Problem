《C和指针》中说用用递归方法计算菲波那切数的计算代价非常大，在递归计算Fibonacci(10)时，Finbonacci(3)的值被计算了21次，在递归计算
Fibonacci(30)时，Fibonacci(3)的值倍计算了317811次（非常大）。之后我设计了一个函数，可以计算出317811这个数值。代码如下：


//设计的函数，递归实现
static int cnt = 0;

void F(int n)
{
	if (n >= 3) {
		if(n = 3)
			cnt++;
		F(n - 1);
		F(n - 2);
	}

	return;
}

main()
{
  F(10);
  printf("%d\n", cnt);
  return 0;
}

但是测试的时候发现输出结果是1。

问题已经解决了，第11行 if(n = 3) 应该是 if(n == 3)，日常犯经典错误。。。 但是值得注意的一点是这个函数在运行时语句的执行顺序，可以在
VS2017里单步调试（有些复杂）。

同时因为算法是用递归实现的，所以效率很低，把这个问题转化成数学问题而不是递归问题会让算法的效率变高（可能只是一个公式吧）。

/*
**用递归方法计算第n个菲波那切数的值
*/

long fibonacci( int n )
{
  if( n <= 2 )
    return 1;
    
    return fibonacci( n - 1) + fibonacci( n - 2 );
}

